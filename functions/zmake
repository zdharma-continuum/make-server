#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-

# Copyright (c) 2022 Sebastian Gniazdowski

# A function or a script from $PATH.

# Set the base and typically useful options.
emulate -LR zsh
setopt extendedglob warncreateglobal typesetsilent noshortloops \
        rcquotes noautopushd multios nomonitor

# Run as script? ZSH_SCRIPT is a Zsh 5.3 addition
if [[ $0 != zmake || -n $ZSH_SCRIPT ]]; then
    0=${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}
    0=${${(M)0##/*}:-$PWD/$0}

    # Such global variable is expected to be typeset'd -g in the plugin.zsh
    # file. Here it's restored in case of the function being run as a script.
    typeset -gA Plugins
    Plugins[MAKE_SERVER_DIR]=${0:h}
fi

# Allow accessing other functions as scripts.
local -aU path=( $path ); local -U PATH=$PATH
path+=( $Plugins[MAKE_SERVER_DIR]/functions )

wait_for_tail() {
    local state
    integer cnt
    while ((1)); do
        LANG=C command sleep 0.5
        state=( $(<$1/.mksrv-state) )
        if [[ $state[1] == finished || $cnt -gt 400 ]]; then
            kill -INT $Plugins[MAKE_SERVER_TAIL_PID]
            return
        fi
        cnt+=1
    done
}

info() {
    m %B{39}MAKE{70} finished with result: {183}${(U)1}{70}.%f%b
}

parse_opts() {
    builtin zparseopts -D -E -err=opt_err e=opt_err \
                -warn=opt_warn w=opt_warn \
                -clean=opt_clean c=opt_clean \
                -info=opt_info
}

local -a opt_err opt_warn opt_clean opt_info
# Find the main git dir uptree.
local -a repos=( (../)#.mksrv-state(DN.) )
# Select the shortest match.
local repo=${${${(On)repos}[1]}:h} tmp
# Remove any ../ from it.
repo=$repo:a

if [[ -z $repo ]]; then
    m {208}%BError:{70} no make-server managed directory found in PWD uptree, exiting…%f%b
    return
fi
# Parse the --warn/-w --err/-e --clean/-c --info/-i options.
parse_opts

# Examine state.
{ local -a state=( $(<$repo/.mksrv-state) ) upmost=( $(<$repo/.mksrv-upmost) ) } 2>/dev/null
if [[ -z $state ]]; then
    m {174}%BNo make-server running for {70}$repo{174}… Exiting…%f%b
    return
fi

upmost[1]=${${upmost[1]:#no-compilation}:-clean}
# Is the compilation currently running?
if [[ $state[1] == ongoing ]]; then
    m %B{70}Make is running…%f%b
    tail -n 10000 -f $state[2] &
    tmp=$!
    Plugins[MAKE_SERVER_TAIL_PID]=$tmp
    wait_for_tail $repo
    LANG=C command sleep 0.5
    upmost=( $(<$repo/.mksrv-upmost) )
    upmost[1]=${${upmost[1]:#no-compilation}:-clean}
    info $upmost[1]
# No – then get last make run output.
else
    info $upmost[1]
    cat $repo/$upmost[3]
    info $upmost[1]
fi

# vim:ft=zsh:tw=80:sw=4:sts=4:et:foldmarker=[[[,]]]
